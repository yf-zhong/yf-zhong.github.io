<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Lock Box | Yifan Zhong </title> <meta name="author" content="Yifan Zhong"> <meta name="description" content="End-to-End Encrypted File-Sharing System"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png?24d909a39b17dac2cd6b7959531e6e8e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yf-zhong.github.io/projects/2_project/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Yifan Zhong </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/experience/">Experience </a> </li> <li class="nav-item "> <a class="nav-link" href="/project/">Project </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Lock Box</h1> <p class="post-description">End-to-End Encrypted File-Sharing System</p> </header> <article> <h2 id="overview">Overview</h2> <p><a href="https://github.com/yf-zhong/end-to-end-encrypted-file-sharing-system" rel="external nofollow noopener" target="_blank">Link to the Project</a></p> <p>This project introduces a client application for a secure file sharing system, leveraging various cryptographic primitives to ensure data security. Imagine something similar to Dropbox, but secured with cryptography so that the server cannot view or tamper with user data.</p> <p>The client is implemented in <strong>Golang</strong> and offers a suite of features including:</p> <ul> <li>Authenticate with a username and password;</li> <li>Save files to the server;</li> <li>Load saved files from the server;</li> <li>Overwrite saved files on the server;</li> <li>Append to saved files on the server;</li> <li>Share saved files with other users; and</li> <li>Revoke access to previously shared files.</li> </ul> <p>This project showcases how cryptography can be wielded to bolster traditional file-sharing systems, providing both utility and peace of mind to its users. Dive into the code to explore the cryptographic techniques employed and how they fortify the entire system against potential security threats.</p> <h2 id="data-structure">Data Structure</h2> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">User</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Username</span>           <span class="kt">string</span> <span class="c">// store for future use (maybe)</span>
    <span class="n">UserBaseKey</span>        <span class="p">[]</span><span class="kt">byte</span>
    <span class="n">UserRSAPrivateKey</span>  <span class="n">PKEDecKey</span> <span class="c">// Public key --&gt; username + "RSA_Public_Key"</span>
    <span class="n">UserSignPrivateKey</span> <span class="n">DSSignKey</span> <span class="c">// Public key --&gt; username + "Digital_Signature_Key"</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FileHeader</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">// UUID &lt;-- "username_filename"</span>
    <span class="n">ShareId</span>   <span class="n">UUID</span>   <span class="c">// the ShareNode for a user</span>
    <span class="n">FHBaseKey</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c">// protect direct ShareNode</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">ShareNode</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">// root UUID &lt;-- random, child UUID &lt;-- "sendername_recipientname_filename"</span>
    <span class="n">FileBodyId</span>   <span class="n">UUID</span>
    <span class="n">ShareNodeId</span>  <span class="n">UUID</span>     <span class="c">// Used in CreateInvitation</span>
    <span class="n">LockboxId</span>    <span class="n">UUID</span>     <span class="c">// Invitation is also the lockbox</span>
    <span class="n">SNBaseKey</span>    <span class="p">[]</span><span class="kt">byte</span>   <span class="c">// Protect following ShareNode if is root, protect itself otherwise</span>
    <span class="n">ChildrenName</span> <span class="p">[]</span><span class="kt">string</span> <span class="c">// Children's name list for the root ShareNode, nil if is child</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FileBody</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">// UUID &lt;-- random</span>
    <span class="n">FBBaseKey</span>   <span class="p">[]</span><span class="kt">byte</span> <span class="c">// Protect all file contents</span>
    <span class="n">LastContent</span> <span class="n">UUID</span>   <span class="c">// Store the last content being appended into the file</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">FileContent</span> <span class="k">struct</span> <span class="p">{</span> <span class="c">// UUID &lt;-- random</span>
    <span class="n">Content</span>     <span class="p">[]</span><span class="kt">byte</span>
    <span class="n">PrevContent</span> <span class="n">UUID</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Invitation</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">ShareId</span>           <span class="n">UUID</span>   <span class="c">// Recipient ShareNode location</span>
    <span class="n">InvitationBaseKey</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c">// Protect lockbox</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Lockbox</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">FileBaseKey</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c">// Protect file</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">SymEncData</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">CypherText</span> <span class="p">[]</span><span class="kt">byte</span>
 <span class="n">MAC</span>        <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">PublicEncData</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">CypherText</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c">// RSA Encrypted Invitation data</span>
 <span class="n">Signature</span>  <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="implementation-details">Implementation Details</h2> <h3 id="user-authentication">User Authentication</h3> <blockquote> <p>User Authenticatoin will be performed with multi-level protection using symmetric encryption and MAC.</p> <p>Since <code class="language-plaintext highlighter-rouge">User</code> will not store any File specified data, and <code class="language-plaintext highlighter-rouge">FileHeader</code> will be retrieved each time we want to access a file, multiple user instance is automatically supported.</p> </blockquote> <h4 id="inituserusername-string-password-string"><code class="language-plaintext highlighter-rouge">InitUser(username string, password string)</code></h4> <ul> <li> <p>User authentication will be done on fly when the user enter username and password. A user base key will be generated from the <code class="language-plaintext highlighter-rouge">username||password</code> using PBKDF.</p> <ul> <li>Generate UUID from <code class="language-plaintext highlighter-rouge">username</code> using <code class="language-plaintext highlighter-rouge">getUUIDFromString()</code> and check that the UUID does’t exist in <em>DataStore</em> </li> <li>Get the root base key from <code class="language-plaintext highlighter-rouge">usename||password</code> using <code class="language-plaintext highlighter-rouge">getUserBaseKey()</code>. Then, derive the root encryption/MAC key from root base key using <code class="language-plaintext highlighter-rouge">getKeyPairFromBase()</code>. This key pair is used to protect the <code class="language-plaintext highlighter-rouge">User</code> itself.</li> <li>Generate user base key from root base key using <code class="language-plaintext highlighter-rouge">getNextBaseKey()</code> and store in <code class="language-plaintext highlighter-rouge">User</code>.</li> <li>Generate RSA key pair and digital signature key pair. The public keys will be stored in <em>KeyStore</em> and the private keys will be stored in <code class="language-plaintext highlighter-rouge">User</code>.</li> <li>Save the <code class="language-plaintext highlighter-rouge">User</code> in to <em>DataStore</em> using root Enc/MAC keys by calling <code class="language-plaintext highlighter-rouge">storeObject()</code>.</li> </ul> </li> </ul> <h4 id="getuserusername-string-password-string"><code class="language-plaintext highlighter-rouge">GetUser(username string, password string)</code></h4> <ul> <li>Generate UUID from username using <code class="language-plaintext highlighter-rouge">getUUIDFromString()</code>, and generate root base key from<code class="language-plaintext highlighter-rouge">generateUserBaseKey()</code>.Then derive root Enc/Mac Keys.</li> <li>Get <code class="language-plaintext highlighter-rouge">User</code> from <em>DataStore</em> with Enc/MAC Keys using <code class="language-plaintext highlighter-rouge">getObject()</code>.</li> </ul> <h3 id="file-storage-and-retrieval">File Storage and Retrieval</h3> <blockquote> <p>File is stored using a multilevel structure: {FileHeader} – {ShareNode} – {FileBody} – {FileContent}</p> <p>The top level <code class="language-plaintext highlighter-rouge">FileHeaderNode</code> is protected by <code class="language-plaintext highlighter-rouge">UserBaseKey</code>. <code class="language-plaintext highlighter-rouge">FileHeader</code> UUID is derived from <code class="language-plaintext highlighter-rouge">username||filename</code> in the userspace on fly. It contains <code class="language-plaintext highlighter-rouge">ShareNode</code> UUID of direct owner <code class="language-plaintext highlighter-rouge">ShareNode</code>. The base key here is derived from <code class="language-plaintext highlighter-rouge">User</code> base key.</p> <p>The collection of <code class="language-plaintext highlighter-rouge">ShareNode</code> is a flattened tree of height 2. Each <code class="language-plaintext highlighter-rouge">ShareNode</code> stores the following FileBody and self’s UUID, the <code class="language-plaintext highlighter-rouge">Lockbox</code> containing the base key to protect <code class="language-plaintext highlighter-rouge">FileBody</code>, a ShareNode base key to derive child and lock base keys, and a children name array. The array will be nil if the <code class="language-plaintext highlighter-rouge">ShareNode</code> is a child, and empty if the <code class="language-plaintext highlighter-rouge">ShareNode</code> is a root.</p> <p><code class="language-plaintext highlighter-rouge">FileBody</code> contains the UUID for the last appended <code class="language-plaintext highlighter-rouge">FileContent</code> and a base key to protect all the <code class="language-plaintext highlighter-rouge">FileContent</code>. The UUID of FileBody is generated randomly.</p> <p><code class="language-plaintext highlighter-rouge">FileContent</code> contains the actual contents and the UUID for the previous content being appended. The UUID of <code class="language-plaintext highlighter-rouge">FileContent</code> is generated randomly.</p> <p>Using <code class="language-plaintext highlighter-rouge">LastContent</code> in <code class="language-plaintext highlighter-rouge">FileBody</code> and <code class="language-plaintext highlighter-rouge">PrevContent</code> in <code class="language-plaintext highlighter-rouge">FileContent</code>, we established a linked file content structure.</p> <p>Since <code class="language-plaintext highlighter-rouge">FileContent</code> is appended indivitually into the content list and we only need to update two UUID, efficiency is guaranteed for <code class="language-plaintext highlighter-rouge">AppendToFile()</code></p> </blockquote> <h4 id="storefilefilename-string-content-byte"><code class="language-plaintext highlighter-rouge">StoreFile(filename string, content []byte)</code></h4> <ul> <li>Based on the file structure described above, we create and store <code class="language-plaintext highlighter-rouge">FileHeader</code>, <code class="language-plaintext highlighter-rouge">ShareNode</code>, <code class="language-plaintext highlighter-rouge">FileBody</code>, and <code class="language-plaintext highlighter-rouge">FileContent</code>, and generate base key for each layer. Base key is used to drive keys to protect sub-layers. Note that key protecting <code class="language-plaintext highlighter-rouge">FileBody</code> will be put into <code class="language-plaintext highlighter-rouge">Lockbox</code>.</li> <li>When <code class="language-plaintext highlighter-rouge">StoreFile</code> is called, the receiver will always be the owner of the file. Thus, we will set <code class="language-plaintext highlighter-rouge">ChildrenName</code> to empty.</li> <li> <code class="language-plaintext highlighter-rouge">LastContent</code> in <code class="language-plaintext highlighter-rouge">FileBody</code> will be set to the <code class="language-plaintext highlighter-rouge">FileContent</code> created in <code class="language-plaintext highlighter-rouge">StoreFile()</code>.</li> </ul> <h4 id="loadfilefilename-string"><code class="language-plaintext highlighter-rouge">LoadFile(filename string)</code></h4> <ul> <li>First get <code class="language-plaintext highlighter-rouge">FileBody</code> by calling <code class="language-plaintext highlighter-rouge">getFileBody()</code>, get the <code class="language-plaintext highlighter-rouge">LastContent</code> in <code class="language-plaintext highlighter-rouge">FileBody</code>, and retrieve that <code class="language-plaintext highlighter-rouge">FileContent</code>.</li> <li>Repeatedly retrieve <code class="language-plaintext highlighter-rouge">FileContent</code> using <code class="language-plaintext highlighter-rouge">PrevContent</code> in <code class="language-plaintext highlighter-rouge">FileContent</code> until <code class="language-plaintext highlighter-rouge">PrevContent</code> is <code class="language-plaintext highlighter-rouge">uuid.Nil</code>. Every time we retrieve a new FileContent, we will appended the content in <code class="language-plaintext highlighter-rouge">FileContent</code> to <code class="language-plaintext highlighter-rouge">contentBytes</code> which will be returned in the end.</li> </ul> <h4 id="appendtofilefilename-string-content-byte"><code class="language-plaintext highlighter-rouge">AppendToFile(filename string, content []byte)</code></h4> <ul> <li>Get the <code class="language-plaintext highlighter-rouge">ShareNode</code> corresponding to the username and filename. Using information in <code class="language-plaintext highlighter-rouge">ShareNode</code> to retrive the <code class="language-plaintext highlighter-rouge">FileBody</code>. We will need information in <code class="language-plaintext highlighter-rouge">ShareNode</code> to update <code class="language-plaintext highlighter-rouge">FileBody</code> in <em>DataStore</em> later.</li> <li>Create a new <code class="language-plaintext highlighter-rouge">FileContent</code> with randomly generated UUID. This UUID will be assigned to <code class="language-plaintext highlighter-rouge">LastContent</code> of <code class="language-plaintext highlighter-rouge">FileBody</code>, and the <code class="language-plaintext highlighter-rouge">LastContent</code> will be assigned to <code class="language-plaintext highlighter-rouge">PrevContent</code> in newly created <code class="language-plaintext highlighter-rouge">FileContent</code>.</li> <li>Finally, store both the new <code class="language-plaintext highlighter-rouge">FileContent</code> and updated <code class="language-plaintext highlighter-rouge">FileBody</code> to <em>DataStore</em>.</li> </ul> <h3 id="file-sharing-and-revocation">File Sharing and Revocation</h3> <blockquote> <p>File sharing is maintained by <code class="language-plaintext highlighter-rouge">ShareNode</code> tree structure. <code class="language-plaintext highlighter-rouge">ShareNode</code> will have different behaviors during create and accept invitation based on <code class="language-plaintext highlighter-rouge">ChildrenName</code>.</p> <p>All the file base keys will be regenerated and distributed along lockbox of the remaining <code class="language-plaintext highlighter-rouge">ShareNode</code>.</p> </blockquote> <h4 id="createinvitationfilename-string-recipientusername-string"><code class="language-plaintext highlighter-rouge">CreateInvitation(filename string, recipientUsername string)</code></h4> <ul> <li>Retrieve <code class="language-plaintext highlighter-rouge">ShareNode</code> of sender using filename and sender name.</li> <li>If sender node is the root (<code class="language-plaintext highlighter-rouge">ChildrenName</code> is not <code class="language-plaintext highlighter-rouge">nil</code>) <ul> <li>Create a new ShareNode for the recipient. The UUID of this node is generated from <code class="language-plaintext highlighter-rouge">sendername + recipientname + filename</code>. <code class="language-plaintext highlighter-rouge">ChildrenName</code> will be <code class="language-plaintext highlighter-rouge">nil</code>, file base key will be copied from sender lockbox to newly created recipient lockbox. Recipient username will be appended to the <code class="language-plaintext highlighter-rouge">ChildrenName</code> array of sender.</li> <li>A child specific base key will be generated based on the <code class="language-plaintext highlighter-rouge">SNBaseKey</code> of sender <code class="language-plaintext highlighter-rouge">ShareNode</code> and recipient username on fly so that different direct children <code class="language-plaintext highlighter-rouge">ShareNode</code> will have different base keys. Since we store the children username in <code class="language-plaintext highlighter-rouge">ChildrenName</code>, we can traverse direct children <code class="language-plaintext highlighter-rouge">ShareNode</code> later while revoking.</li> </ul> </li> <li>If sender node is not the root <ul> <li>Simply use the current ShareNode as the recipient ShareNode since only the owner will be able to revoke the access to its direct recipients.</li> </ul> </li> <li>Using the recipient ShareNode we created above, we will create a new <code class="language-plaintext highlighter-rouge">Invitation</code> which store the recipient <code class="language-plaintext highlighter-rouge">ShareNode</code> UUID and child specified <code class="language-plaintext highlighter-rouge">ShareNode</code> base key.</li> <li>Finally, this invitation is encrypted using the <code class="language-plaintext highlighter-rouge">RSAPublicKey</code> from recipient stored on <em>KeyStore</em> and sign the encryed data using <code class="language-plaintext highlighter-rouge">DSSignKey</code> in <code class="language-plaintext highlighter-rouge">User</code> of recipient. This cyphertext and signature pair will be stored in <code class="language-plaintext highlighter-rouge">PublicEncData</code>. The UUID of <code class="language-plaintext highlighter-rouge">InvitationData</code> is generated from <code class="language-plaintext highlighter-rouge">"Invitation: " + sendername + filename + recipientname</code>. Note that while children <code class="language-plaintext highlighter-rouge">ShareNode</code> also generate UUID from these three string, they are using the different combination and extra string <code class="language-plaintext highlighter-rouge">"Invitation: "</code>, so that the hashed bytes will have no collision.</li> <li> <code class="language-plaintext highlighter-rouge">PublicEncData</code> is directly putting into <em>DataStore</em> without protection.</li> </ul> <h4 id="acceptinvitationsenderusername-string-invitationptr-uuid-filename-string"><code class="language-plaintext highlighter-rouge">AcceptInvitation(senderUsername string, invitationPtr UUID, filename string)</code></h4> <ul> <li>Retrieve <code class="language-plaintext highlighter-rouge">InvitationData</code> after checking that the UUID exist and delete the <code class="language-plaintext highlighter-rouge">Invitation</code> in <em>DataStore</em>.</li> <li>Decrypt cyphertext using private key stored in recipient <code class="language-plaintext highlighter-rouge">User</code> after verifing the signature using digital signature verify key stored in <em>KeyStore</em>.</li> <li>Create the <code class="language-plaintext highlighter-rouge">FileHeader</code> whose UUID is generated from filename and username, store the <code class="language-plaintext highlighter-rouge">ShareNode</code> UUID in <code class="language-plaintext highlighter-rouge">Invitation</code> to newly created <code class="language-plaintext highlighter-rouge">FileHeader</code>.</li> </ul> <h4 id="revokeaccessfilename-string-recipientusername-string"><code class="language-plaintext highlighter-rouge">RevokeAccess(filename string, recipientUsername string)</code></h4> <ul> <li>Revocation will be done only on the <code class="language-plaintext highlighter-rouge">ShareNode</code> level. The only change after revocation is the <code class="language-plaintext highlighter-rouge">FileBaseKey</code> in the <code class="language-plaintext highlighter-rouge">Lockbox</code>. By store the updated key in lockbox, we can revoke recipients’ access.</li> <li> <p>Check if the <code class="language-plaintext highlighter-rouge">Invitation</code> is accpted and if the shared file exist. If so, we will delet corresponding <code class="language-plaintext highlighter-rouge">ShareNode</code> and <code class="language-plaintext highlighter-rouge">Invitation</code>.</p> </li> <li>While deleting the child <code class="language-plaintext highlighter-rouge">ShareNode</code>, we first derive a new file base key and distribute it to all the child <code class="language-plaintext highlighter-rouge">ShareNode</code> other than the revoked one. Only the Lockbox is re-encrupted and stored at the same location.</li> </ul> <h2 id="helper-methods">Helper Methods</h2> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/* Store an object into the Datastore with given UUID */</span>
<span class="k">func</span> <span class="n">storeSymEncObject</span><span class="p">(</span><span class="n">dataId</span> <span class="n">UUID</span><span class="p">,</span> <span class="n">object</span> <span class="k">interface</span><span class="p">{},</span> <span class="n">encKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">macKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get an object from the Datastore */</span>
<span class="k">func</span> <span class="n">getSymEncObject</span><span class="p">(</span><span class="n">dataId</span> <span class="n">UUID</span><span class="p">,</span> <span class="n">encKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">macKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">object</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Store an object into the Datastore with given UUID */</span>
<span class="k">func</span> <span class="n">storePublicEncObject</span><span class="p">(</span><span class="n">dataId</span> <span class="n">UUID</span><span class="p">,</span> <span class="n">object</span> <span class="k">interface</span><span class="p">{},</span> <span class="n">publicKey</span> <span class="n">PKEEncKey</span><span class="p">,</span> <span class="n">signKey</span> <span class="n">DSSignKey</span><span class="p">)</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get an object from the Datastore */</span>
<span class="k">func</span> <span class="n">getPublicEncObject</span><span class="p">(</span><span class="n">dataId</span> <span class="n">UUID</span><span class="p">,</span> <span class="n">privateKey</span> <span class="n">PKEDecKey</span><span class="p">,</span> <span class="n">verifyKey</span> <span class="n">DSVerifyKey</span><span class="p">,</span> <span class="n">object</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get Fileheader from username and filename */</span>
<span class="k">func</span> <span class="p">(</span><span class="n">userdata</span> <span class="o">*</span><span class="n">User</span><span class="p">)</span> <span class="n">getFileHeader</span><span class="p">(</span><span class="n">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="n">fileHeader</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get ShareNode from username and filename */</span>
<span class="k">func</span> <span class="p">(</span><span class="n">userdata</span> <span class="o">*</span><span class="n">User</span><span class="p">)</span> <span class="n">getShareNode</span><span class="p">(</span><span class="n">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="n">shareNode</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get file base key from ShareNode */</span>
<span class="k">func</span> <span class="p">(</span><span class="n">shareNode</span> <span class="o">*</span><span class="n">ShareNode</span><span class="p">)</span> <span class="n">getSNFileBaseKey</span><span class="p">()</span> <span class="p">(</span><span class="n">fileBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get FileBody from username and filename*/</span>
<span class="k">func</span> <span class="p">(</span><span class="n">userdata</span> <span class="o">*</span><span class="n">User</span><span class="p">)</span> <span class="n">getFileBody</span><span class="p">(</span><span class="n">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="n">fileBody</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get UUID from byte string */</span>
<span class="k">func</span> <span class="n">getUUIDFromString</span><span class="p">(</span><span class="n">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">uid</span> <span class="n">UUID</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get base key from username + password to derive enc/mac key*/</span>
<span class="k">func</span> <span class="n">getUserBaseKey</span><span class="p">(</span><span class="n">username</span> <span class="kt">string</span><span class="p">,</span> <span class="n">password</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">baseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>

<span class="c">/* Get FileHeader base key from user base key and filename*/</span>
<span class="k">func</span> <span class="n">getFileHeaderBaseKey</span><span class="p">(</span><span class="n">originalBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">newBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get encryption &amp; MAC key from base key */</span>
<span class="k">func</span> <span class="n">getKeyPairFromBase</span><span class="p">(</span><span class="n">baseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">encKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">macKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get encryption &amp; MAC key for the ShareNode of a given recipient */</span>
<span class="k">func</span> <span class="n">getChildBaseKey</span><span class="p">(</span><span class="n">baseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">recipientName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">childBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get a new Lockbox base key */</span>
<span class="k">func</span> <span class="n">getLockboxBaseKey</span><span class="p">(</span><span class="n">baseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">lockboxBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>

<span class="c">/* Get next base key from current one */</span>
<span class="k">func</span> <span class="n">getNextBaseKey</span><span class="p">(</span><span class="n">originalBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">newBaseKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Yifan Zhong. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: February 15, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>